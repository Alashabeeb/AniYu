import {
  addDoc, collection, deleteDoc, doc, getDoc, getDocs, orderBy, query, serverTimestamp, updateDoc, where
} from 'firebase/firestore';
import { deleteObject, getDownloadURL, ref, uploadBytesResumable } from 'firebase/storage';
import {
  ArrowLeft,
  Bell,
  BookOpen,
  CheckCircle,
  Eye,
  File as FileIcon, // ✅ Imported generic File icon
  FileImage,
  Image as ImageIcon,
  Layers,
  Loader2,
  Plus,
  Trash2,
  XCircle
} from 'lucide-react';
import { useEffect, useState } from 'react';
import { auth, db, storage } from './firebase';

const GENRES_LIST = [
  "Action", "Adventure", "Comedy", "Drama", "Fantasy", 
  "Horror", "Magic", "Mecha", "Music", "Mystery", 
  "Psychological", "Romance", "Sci-Fi", "Slice of Life", 
  "Sports", "Supernatural", "Thriller", "Isekai"
];

const STATUS_OPTIONS = ["Pending", "Ongoing", "Completed", "Hiatus"];

export default function MangaUpload() {
  // --- GLOBAL STATE ---
  const [view, setView] = useState('list');
  const [mangaList, setMangaList] = useState([]);
  const [loadingList, setLoadingList] = useState(true);
  const [libraryTab, setLibraryTab] = useState('Ongoing');
  
  // --- USER ROLE STATE ---
  const [currentUser, setCurrentUser] = useState(null);

  // --- FORM STATE ---
  const [loading, setLoading] = useState(false);
  const [progress, setProgress] = useState(0);
  const [status, setStatus] = useState(''); 
  const [createdMangaId, setCreatedMangaId] = useState(null);
  const [isEditMode, setIsEditMode] = useState(false);
  const [notifyUsers, setNotifyUsers] = useState(true);

  // --- DETAILS VIEW STATE ---
  const [selectedManga, setSelectedManga] = useState(null);
  const [selectedMangaChapters, setSelectedMangaChapters] = useState([]);
  const [selectedMangaComments, setSelectedMangaComments] = useState([]);

  // HEADER STATE (Manga Form)
  const [mangaCover, setMangaCover] = useState(null); 
  const [existingCoverUrl, setExistingCoverUrl] = useState(''); 
  const [mangaTitle, setMangaTitle] = useState('');
  const [author, setAuthor] = useState('');
  const [releaseYear, setReleaseYear] = useState(''); 
  const [synopsis, setSynopsis] = useState('');
  const [selectedGenres, setSelectedGenres] = useState([]);
  const [mangaStatus, setMangaStatus] = useState('Ongoing'); 

  // BODY STATE (Chapter Form)
  const [chapters, setChapters] = useState([]);
  const [deletedChapters, setDeletedChapters] = useState([]);

  // --- 1. FETCH USER ROLE ON MOUNT ---
  useEffect(() => {
    const fetchUser = async () => {
        if (auth.currentUser) {
            const userSnap = await getDoc(doc(db, "users", auth.currentUser.uid));
            if (userSnap.exists()) {
                setCurrentUser({ uid: auth.currentUser.uid, ...userSnap.data() });
            }
        }
    };
    fetchUser();
  }, []);

  // --- 2. FETCH LIST (DEPENDS ON ROLE) ---
  useEffect(() => {
    if (currentUser) {
        fetchMangaList();
    }
  }, [currentUser, libraryTab]);

  const fetchMangaList = async () => {
    setLoadingList(true);
    try {
      let q;
      const listRef = collection(db, 'manga');
      
      if (currentUser.role === 'manga_producer') {
          // PRODUCER: See MY manga only
          q = query(listRef, where('uploaderId', '==', currentUser.uid));
      } else {
          // ADMIN: See ALL manga
          q = query(listRef, orderBy('views', 'desc'));
      }

      const snapshot = await getDocs(q);
      let list = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
      
      // Filter by Status Tab
      list = list.filter(m => (m.status || 'Ongoing') === libraryTab);

      setMangaList(list);
    } catch (error) { 
        console.error("Error fetching list:", error); 
    } finally { 
        setLoadingList(false); 
    }
  };

  const sendAutoNotification = async (title, body) => {
      try {
          const usersSnap = await getDocs(collection(db, "users"));
          const promises = usersSnap.docs.map(userDoc => 
              addDoc(collection(db, "users", userDoc.id, "notifications"), {
                  title, body, read: false, createdAt: serverTimestamp(), type: 'system'
              })
          );
          await Promise.all(promises);
      } catch (e) { console.error("Notification failed:", e); }
  };

  // --- ACTIONS ---

  const handleApprove = async (manga) => {
      if (!window.confirm(`Approve "${manga.title}"? It will go live immediately.`)) return;
      try {
          await updateDoc(doc(db, 'manga', manga.id), { status: 'Ongoing' });
          
          await sendAutoNotification(
              `New Manga: ${manga.title}`,
              `Read ${manga.title} now on AniYu!`
          );

          alert("Approved & Published!");
          fetchMangaList();
      } catch (e) { alert(e.message); }
  };

  const handleReject = async (manga) => {
      if (!window.confirm(`Reject and delete "${manga.title}"?`)) return;
      handleDelete(manga);
  };

  const handleCreateNew = () => {
    setCreatedMangaId(null);
    setIsEditMode(false);
    setMangaTitle(''); setAuthor(''); setReleaseYear(''); setSynopsis(''); setSelectedGenres([]); setExistingCoverUrl(''); setMangaCover(null);
    
    if (currentUser?.role === 'manga_producer') {
        setMangaStatus('Pending');
    } else {
        setMangaStatus('Ongoing'); 
    }

    setChapters([{ id: Date.now(), number: 1, title: '', pages: [], existingPages: [], isNew: true }]);
    setDeletedChapters([]);
    setNotifyUsers(true);
    setView('form');
  };

  const handleEdit = async (manga) => {
    setCreatedMangaId(manga.id);
    setIsEditMode(true);
    setMangaTitle(manga.title);
    setAuthor(manga.author || '');
    setReleaseYear(manga.year || ''); 
    setSynopsis(manga.synopsis);
    setSelectedGenres(manga.genres || []);
    setExistingCoverUrl(manga.images?.jpg?.image_url || '');
    setMangaCover(null);
    setNotifyUsers(true);
    setMangaStatus(manga.status || 'Ongoing');

    setDeletedChapters([]);
    setStatus('Fetching chapters...');
    try {
      const q = query(collection(db, 'manga', manga.id, 'chapters'), orderBy('number', 'asc'));
      const chSnap = await getDocs(q);
      const fetchedChaps = chSnap.docs.map(doc => ({
        id: doc.id, 
        number: doc.data().number, 
        title: doc.data().title,
        existingPages: doc.data().pages || [], 
        pages: [], 
        isNew: false
      }));
      setChapters(fetchedChaps.length > 0 ? fetchedChaps : [{ id: Date.now(), number: 1, title: '', pages: [], existingPages: [], isNew: true }]);
      setView('form');
    } catch (e) { alert(e.message); }
    setStatus('');
  };

  const handleViewDetails = async (manga) => {
    setSelectedManga(manga);
    setView('details');
    try {
      const qCh = query(collection(db, 'manga', manga.id, 'chapters'), orderBy('number', 'asc'));
      const chSnap = await getDocs(qCh);
      setSelectedMangaChapters(chSnap.docs.map(doc => ({ id: doc.id, ...doc.data() })));

      const qComm = query(collection(db, 'manga', manga.id, 'comments'), orderBy('createdAt', 'desc'));
      const commSnap = await getDocs(qComm);
      setSelectedMangaComments(commSnap.docs.map(doc => ({ id: doc.id, ...doc.data() })));
    } catch (e) { console.error(e); }
  };

  const handleDelete = async (manga) => {
    if (currentUser.role === 'manga_producer' && manga.uploaderId !== currentUser.uid) {
        return alert("You can only delete your own uploads.");
    }

    if (!window.confirm(`WARNING: This will permanently delete "${manga.title}".\n\nAre you sure?`)) return;
    
    setMangaList(prev => prev.filter(m => m.id !== manga.id));
    if (view === 'details') setView('list');

    try {
      if (manga.images?.jpg?.image_url) {
        try { await deleteObject(ref(storage, manga.images.jpg.image_url)); } catch (e) {}
      }

      const chSnapshot = await getDocs(collection(db, 'manga', manga.id, 'chapters'));
      const deletePromises = chSnapshot.docs.map(async (docSnap) => {
          const ch = docSnap.data();
          if (ch.pages) {
              for (const pageUrl of ch.pages) {
                  try { await deleteObject(ref(storage, pageUrl)); } catch (e) {}
              }
          }
          return deleteDoc(doc(db, 'manga', manga.id, 'chapters', docSnap.id));
      });

      await Promise.all(deletePromises);
      await deleteDoc(doc(db, 'manga', manga.id));
      alert(`"${manga.title}" has been deleted.`);

    } catch (e) { 
        alert("Error during deletion: " + e.message); 
        fetchMangaList();
    }
  };

  // --- FORM LOGIC ---
  const addChapterForm = () => {
    const nextNum = chapters.length > 0 ? Number(chapters[chapters.length - 1].number) + 1 : 1;
    setChapters([...chapters, { id: Date.now(), number: nextNum, title: '', pages: [], existingPages: [], isNew: true }]);
  };

  const removeChapterForm = (index) => {
    const chToRemove = chapters[index];
    if (!chToRemove.isNew && chToRemove.id) {
        setDeletedChapters(prev => [...prev, chToRemove]);
    }
    const newChaps = [...chapters]; 
    newChaps.splice(index, 1); 
    setChapters(newChaps); 
  };

  const updateChapterState = (index, field, value) => { const newChaps = [...chapters]; newChaps[index][field] = value; setChapters(newChaps); };

  // ✅ UPDATED: Allowed ANY file type (Removed strict image check)
  const handlePageUpload = (index, files) => {
      const fileArray = Array.from(files);
      const newChaps = [...chapters];
      newChaps[index].pages = [...newChaps[index].pages, ...fileArray];
      setChapters(newChaps);
  };

  const removePage = (chIndex, pageIndex, isExisting) => {
      const newChaps = [...chapters];
      if (isExisting) {
          newChaps[chIndex].existingPages.splice(pageIndex, 1);
      } else {
          newChaps[chIndex].pages.splice(pageIndex, 1);
      }
      setChapters(newChaps);
  };

  // ✅ KEEPING COVER STRICT: Image Validation for Cover
  const handleFileChange = (e, setter) => { 
      const file = e.target.files[0];
      if (!file) return;

      if (!file.type.startsWith('image/')) {
          alert("Invalid file type. Please upload a valid image file for the cover.");
          e.target.value = null; // Reset input
          return;
      }
      setter(file); 
  };
  
  const uploadFile = (file, path) => {
    return new Promise((resolve, reject) => {
      const storageRef = ref(storage, `${path}/${Date.now()}_${file.name}`);
      const uploadTask = uploadBytesResumable(storageRef, file);
      uploadTask.on('state_changed', 
        (snapshot) => {
          const p = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
          if (path.includes('pages')) setProgress(Math.round(p));
        },
        (error) => reject(error),
        async () => { 
            const url = await getDownloadURL(uploadTask.snapshot.ref);
            resolve(url);
        }
      );
    });
  };

  const handlePublish = async (e) => {
    e.preventDefault();
    if (!mangaTitle) { alert("Title is required."); return; }
    if (!isEditMode && !mangaCover) { alert("Cover is required."); return; }
    
    setLoading(true);
    setStatus('Saving Manga Details...');
    setProgress(0);

    try {
      const coverResult = mangaCover ? await uploadFile(mangaCover, 'manga_covers') : null;
      const finalCoverUrl = coverResult || existingCoverUrl;
      let mangaId = createdMangaId;

      let finalStatus = mangaStatus;
      if (currentUser?.role === 'manga_producer' && !isEditMode) finalStatus = 'Pending';

      const mangaData = {
        title: mangaTitle, 
        author: author || 'Unknown', 
        year: releaseYear || 'N/A', 
        synopsis, 
        genres: selectedGenres, 
        images: { jpg: { image_url: finalCoverUrl } }, 
        type: 'Manga', 
        status: finalStatus,
        uploaderId: currentUser.uid,
        updatedAt: serverTimestamp()
      };

      if (isEditMode && mangaId) {
        await updateDoc(doc(db, 'manga', mangaId), mangaData);
      } else {
        const ref = await addDoc(collection(db, 'manga'), { 
          ...mangaData, 
          createdAt: serverTimestamp(), 
          views: 0, likes: 0, dislikes: 0, rating: 0 
        });
        mangaId = ref.id;
        setCreatedMangaId(mangaId);
      }

      if (deletedChapters.length > 0) {
          setStatus('Removing deleted chapters...');
          for (const delCh of deletedChapters) {
              await deleteDoc(doc(db, 'manga', mangaId, 'chapters', delCh.id));
          }
      }

      const totalOps = chapters.length;
      let completedOps = 0;

      for (let i = 0; i < chapters.length; i++) {
        const ch = chapters[i];
        setStatus(`Uploading Chapter ${ch.number} pages...`);
        
        const newPageUrls = [];
        for (const file of ch.pages) {
            const url = await uploadFile(file, `manga_pages/${mangaId}/ch_${ch.number}`);
            newPageUrls.push(url);
        }

        const finalPages = [...(ch.existingPages || []), ...newPageUrls];

        const chData = {
          title: ch.title || `Chapter ${ch.number}`, 
          number: Number(ch.number),
          pages: finalPages,
          updatedAt: serverTimestamp()
        };

        if (ch.isNew) {
           await addDoc(collection(db, 'manga', mangaId, 'chapters'), { ...chData, createdAt: serverTimestamp() });
        } else {
           await updateDoc(doc(db, 'manga', mangaId, 'chapters', ch.id), chData);
        }
        completedOps++;
        setProgress(Math.round((completedOps / totalOps) * 100));
      }

      setStatus('Success!');
      if (notifyUsers && finalStatus !== 'Pending') {
          await sendAutoNotification(isEditMode ? `New Chapter: ${mangaTitle}` : `New Manga: ${mangaTitle}`, `Read ${mangaTitle} now on AniYu!`);
      }

      alert(finalStatus === 'Pending' ? "Submitted for Review! Waiting for Admin approval." : "Published!");
      setView('list'); 
      setLibraryTab(finalStatus);

    } catch (error) { console.error(error); alert('Error: ' + error.message); } finally { setLoading(false); }
  };

  // --- RENDER: DETAILS VIEW ---
  if (view === 'details' && selectedManga) {
      return (
        <div className="container">
            <button onClick={() => setView('list')} style={{ display: 'flex', alignItems: 'center', gap: 5, border: 'none', background: 'none', cursor: 'pointer', color: '#6b7280', fontWeight: 600, marginBottom: 20 }}>
                <ArrowLeft size={18} /> Back to Library
            </button>
            <div className="card">
                <div className="card-header blue"><span>{selectedManga.title} - Chapters</span></div>
                <div className="card-body">
                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))', gap: 15 }}>
                        {selectedMangaChapters.map(ch => (
                            <div key={ch.id} style={{ padding: 15, background: '#f9fafb', borderRadius: 8, border: '1px solid #e5e7eb' }}>
                                <div style={{ fontWeight: 700, marginBottom: 5 }}>Chapter {ch.number}</div>
                                <div style={{ fontSize: '0.8rem', color: '#6b7280' }}>{ch.pages?.length || 0} Files</div>
                            </div>
                        ))}
                    </div>
                </div>
            </div>
        </div>
      );
  }

  // --- RENDER: LIST VIEW ---
  if (view === 'list') {
    const filteredMangaList = mangaList.filter(item => (item.status || 'Ongoing') === libraryTab);

    return (
      <div className="container">
        <div className="card" style={{ marginBottom: 30, background: 'linear-gradient(135deg, #ec4899 0%, #8b5cf6 100%)', border: 'none' }}>
           <div className="card-body" style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: '50px 20px', textAlign: 'center' }}>
              <div style={{ color: 'white', marginBottom: 15 }}>
                <h1 style={{ fontSize: '2rem', fontWeight: 900, margin: 0 }}>Manga Studio</h1>
                <p style={{ opacity: 0.9, marginTop: 5 }}>Manage your manga library and chapters</p>
              </div>
              <button onClick={handleCreateNew} className="btn-publish" style={{ width: 'auto', padding: '15px 40px', background: 'white', color: '#ec4899', boxShadow: '0 10px 25px rgba(0,0,0,0.2)' }}><Plus size={24} /> UPLOAD NEW MANGA</button>
           </div>
        </div>

        <div style={{ display: 'flex', gap: 10, borderBottom: '2px solid #e5e7eb', paddingBottom: 10, marginBottom: 20 }}>
            {STATUS_OPTIONS.map(status => (
                <button 
                  key={status}
                  onClick={() => setLibraryTab(status)}
                  style={{
                      padding: '8px 20px',
                      borderRadius: 20,
                      border: 'none',
                      background: libraryTab === status ? (status === 'Pending' ? '#f59e0b' : '#ec4899') : 'transparent',
                      color: libraryTab === status ? 'white' : '#6b7280',
                      fontWeight: 700,
                      cursor: 'pointer',
                      transition: 'all 0.2s'
                  }}
                >
                    {status}
                </button>
            ))}
        </div>

        <div style={{ display: 'grid', gap: 20 }}>
          {filteredMangaList.length === 0 && <div style={{textAlign:'center', color:'#9ca3af', padding:40}}>No manga found in {libraryTab}.</div>}
          
          {filteredMangaList.map((manga, index) => (
            <div key={manga.id} className="card" style={{ marginBottom: 0 }}>
              <div style={{ display: 'flex', alignItems: 'center', padding: 20, gap: 20 }}>
                <div style={{ width: 60, height: 80, borderRadius: 10, overflow: 'hidden', flexShrink: 0, position:'relative' }}>
                    <img src={manga.images?.jpg?.image_url} style={{ width: '100%', height: '100%', objectFit: 'cover' }} />
                </div>
                <div style={{ flex: 1 }}>
                  <h3 style={{ margin: '0 0 5px 0', fontSize: '1.1rem', fontWeight: 700 }}>{manga.title}</h3>
                  <div style={{ display: 'flex', gap: 12, alignItems:'center', marginTop: 5 }}>
                      <span style={{ fontSize: '0.8rem', color: '#6b7280', display: 'flex', alignItems: 'center', gap: 4 }}><Eye size={14} /> {manga.views || 0}</span>
                  </div>
                </div>
                <div style={{ display: 'flex', gap: 10 }}>
                   {/* ✅ ADMIN APPROVAL BUTTONS */}
                   {libraryTab === 'Pending' && currentUser?.role !== 'manga_producer' && (
                       <>
                           <button onClick={() => handleApprove(manga)} style={{ padding: '8px 12px', borderRadius: 8, background: '#dcfce7', color: '#166534', fontWeight: 'bold', border: '1px solid #bbf7d0', display:'flex', gap:5, cursor:'pointer' }}><CheckCircle size={16}/> Approve</button>
                           <button onClick={() => handleReject(manga)} style={{ padding: '8px 12px', borderRadius: 8, background: '#fee2e2', color: '#991b1b', fontWeight: 'bold', border: '1px solid #fecaca', display:'flex', gap:5, cursor:'pointer' }}><XCircle size={16}/> Reject</button>
                       </>
                   )}
                   
                   <button onClick={() => handleViewDetails(manga)} style={{ padding: '8px 16px', borderRadius: 8, border: '1px solid #e5e7eb', background: 'white', cursor: 'pointer', fontWeight: 600 }}>View</button>
                   <button onClick={() => handleEdit(manga)} style={{ padding: '8px 16px', borderRadius: 8, border: '1px solid #bfdbfe', background: '#eff6ff', color: '#2563eb', cursor: 'pointer', fontWeight: 600 }}>Edit</button>
                   <button onClick={() => handleDelete(manga)} style={{ padding: '8px 16px', borderRadius: 8, border: '1px solid #fecaca', background: '#fef2f2', color: '#dc2626', cursor: 'pointer', fontWeight: 600 }}>Delete</button>
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>
    );
  }

  // --- RENDER: FORM VIEW ---
  return (
    <div className="container">
      <button onClick={() => setView('list')} style={{ display: 'flex', alignItems: 'center', gap: 5, border: 'none', background: 'none', cursor: 'pointer', color: '#6b7280', fontWeight: 600, marginBottom: 20 }}>
        <ArrowLeft size={18} /> Back to List
      </button>

      <div className="page-header">
        <div className="page-title"><h1>{isEditMode ? "Manage Manga" : "New Manga Upload"}</h1></div>
        {!loading && (
           <div style={{display:'flex', gap: 15, alignItems:'center'}}>
               <div 
                 onClick={() => setNotifyUsers(!notifyUsers)}
                 style={{display:'flex', alignItems:'center', gap: 8, cursor:'pointer', background:'white', padding:'10px 15px', borderRadius:10, border: notifyUsers ? '1px solid #db2777' : '1px solid #e5e7eb'}}
               >
                   <Bell size={18} className={notifyUsers ? "text-pink-600 fill-current" : "text-gray-400"} />
                   <span style={{fontWeight:700, fontSize:'0.9rem', color: notifyUsers ? '#db2777' : '#6b7280'}}>Notify Users</span>
               </div>
               <button onClick={handlePublish} className="btn-publish" style={{ width: 'auto', padding: '12px 30px', fontSize: '1rem', background: '#db2777' }}>
                   {currentUser?.role === 'manga_producer' ? "Submit for Review" : "Save All Changes"}
               </button>
           </div>
        )}
      </div>

      <form onSubmit={handlePublish}>
        {/* HEADER: MANGA DETAILS */}
        <div className="card">
          <div className="card-header blue" style={{justifyContent:'space-between', background:'#fce7f3', color:'#831843'}}>
              <div style={{display:'flex', alignItems:'center', gap:10}}><BookOpen size={24} /> <span>Header: Manga Details</span></div>
              
              {/* ✅ HIDE STATUS FOR PRODUCER */}
              {currentUser?.role !== 'manga_producer' ? (
                  <div style={{ display: 'flex', alignItems: 'center', gap: 10, background:'white', padding:'5px 15px', borderRadius:12, border:'1px solid #fbcfe8' }}>
                      <select value={mangaStatus} onChange={(e) => setMangaStatus(e.target.value)} style={{border:'none', fontWeight:700, outline:'none', fontSize:'0.95rem', color:'#db2777'}}>
                          {STATUS_OPTIONS.map(s => <option key={s} value={s}>{s}</option>)}
                      </select>
                  </div>
              ) : (
                  <div style={{ background: '#fffbeb', color: '#d97706', padding: '5px 15px', borderRadius: 12, fontWeight: 'bold', fontSize: '0.9rem', border: '1px solid #fcd34d' }}>
                      {mangaStatus === 'Pending' ? "Waiting for Approval" : mangaStatus}
                  </div>
              )}
          </div>
          <div className="card-body">
            <div className="grid-12">
              <div>
                <span className="form-label">Cover</span>
                {/* ✅ KEEPING COVER STRICT: accept="image/*" */}
                <input type="file" accept="image/*" className="hidden" id="mangaCover" onChange={(e) => handleFileChange(e, setMangaCover)} />
                <label htmlFor="mangaCover" className={`upload-zone ${mangaCover ? 'active' : ''}`}>
                  {mangaCover ? <img src={URL.createObjectURL(mangaCover)} /> : existingCoverUrl ? <img src={existingCoverUrl} /> : <div style={{textAlign:'center', color:'#9ca3af'}}><ImageIcon size={30}/> Upload</div>}
                </label>
              </div>
              <div>
                <div className="grid-3" style={{marginBottom:0, display:'grid', gridTemplateColumns: '2fr 1fr 1fr', gap: 20}}>
                    <div className="form-group"><span className="form-label">Title</span><input type="text" className="input-field" value={mangaTitle} onChange={e => setMangaTitle(e.target.value)} /></div>
                    <div className="form-group"><span className="form-label">Author</span><input type="text" className="input-field" value={author} onChange={e => setAuthor(e.target.value)} /></div>
                    <div className="form-group"><span className="form-label">Year</span><input type="number" className="input-field" placeholder="2024" value={releaseYear} onChange={e => setReleaseYear(e.target.value)} /></div>
                </div>
                <div className="form-group"><span className="form-label">Synopsis</span><textarea className="textarea-field" value={synopsis} onChange={e => setSynopsis(e.target.value)}></textarea></div>
                <div className="form-group"><span className="form-label">Genres</span><div className="chips-container">{GENRES_LIST.map(g => <div key={g} className={`chip ${selectedGenres.includes(g) ? 'selected' : ''}`} onClick={() => { if(selectedGenres.includes(g)) setSelectedGenres(prev=>prev.filter(x=>x!==g)); else if(selectedGenres.length<3) setSelectedGenres([...selectedGenres, g]); }}>{g}</div>)}</div></div>
              </div>
            </div>
          </div>
        </div>

        {/* BODY: CHAPTER LIST */}
        <div style={{ marginBottom: 20 }}>
          <h2 style={{ fontSize: '1.5rem', fontWeight: 800, marginBottom: 15, display: 'flex', alignItems: 'center', gap: 10 }}><Layers color="#db2777" /> Chapters ({chapters.length})</h2>
          {chapters.map((ch, index) => (
            <div key={ch.id} className="card" style={{ border: '2px solid #f3f4f6' }}>
              <div className="card-header" style={{ padding: '15px 20px', background: '#fdf2f8', display: 'flex', justifyContent: 'space-between', color:'#831843' }}>
                <span style={{ fontSize: '1rem', fontWeight:700 }}>Chapter {ch.number} Form</span>
                {chapters.length > 1 && <button type="button" onClick={() => removeChapterForm(index)} style={{ color: '#ef4444', background: 'none', border: 'none', cursor: 'pointer' }}><Trash2 size={18} /></button>}
              </div>
              <div className="card-body" style={{ padding: 20 }}>
                <div className="grid-2">
                   <div>
                      <div className="form-group">
                         <span className="form-label">Files Upload</span>
                         {/* ✅ REMOVED accept="image/*" - Allow any file type */}
                         <input type="file" multiple className="hidden" id={`pages-${ch.id}`} onChange={(e) => handlePageUpload(index, e.target.files)} />
                         <label htmlFor={`pages-${ch.id}`} className="upload-zone" style={{ minHeight: 120 }}>
                            <div style={{textAlign:'center', color:'#db2777'}}><FileImage size={30}/> Add Files</div>
                         </label>
                      </div>
                      <div style={{display:'flex', gap:10}}>
                         <div style={{width:80}}><span className="form-label">No.</span><input type="number" className="input-field" value={ch.number} onChange={(e) => updateChapterState(index, 'number', e.target.value)} /></div>
                         <div style={{flex:1}}><span className="form-label">Title</span><input type="text" className="input-field" value={ch.title} onChange={(e) => updateChapterState(index, 'title', e.target.value)} /></div>
                      </div>
                   </div>
                   
                   {/* PREVIEW PAGES/FILES */}
                   <div style={{ background: '#f8fafc', padding: 10, borderRadius: 10, maxHeight: 300, overflowY: 'auto' }}>
                       <span className="form-label">Preview ({ch.existingPages.length + ch.pages.length})</span>
                       <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(80px, 1fr))', gap: 10 }}>
                           {/* Existing Pages (Assumed Images from URL) */}
                           {ch.existingPages.map((url, pIdx) => (
                               <div key={`ex-${pIdx}`} style={{position:'relative'}}>
                                   <img src={url} style={{width:'100%', borderRadius:5}} />
                                   <div onClick={() => removePage(index, pIdx, true)} style={{position:'absolute', top:0, right:0, background:'red', color:'white', borderRadius:'50%', width:15, height:15, fontSize:10, display:'flex', alignItems:'center', justifyContent:'center', cursor:'pointer'}}>x</div>
                               </div>
                           ))}
                           {/* New Files - ✅ UPDATED PREVIEW LOGIC */}
                           {ch.pages.map((file, pIdx) => (
                               <div key={`new-${pIdx}`} style={{position:'relative', width: '100%'}}>
                                   {file.type.startsWith('image/') ? (
                                       <img src={URL.createObjectURL(file)} style={{width:'100%', borderRadius:5, opacity: 0.7}} />
                                   ) : (
                                       <div style={{width:'100%', height: 100, background:'#e5e7eb', display:'flex', flexDirection:'column', alignItems:'center', justifyContent:'center', borderRadius:5, padding:5}}>
                                           <FileIcon size={24} className="text-gray-500" />
                                           <span style={{fontSize:10, wordBreak:'break-all', textAlign:'center', marginTop: 5, color:'#4b5563'}}>{file.name.slice(0, 15)}...</span>
                                       </div>
                                   )}
                                   <div onClick={() => removePage(index, pIdx, false)} style={{position:'absolute', top:0, right:0, background:'red', color:'white', borderRadius:'50%', width:15, height:15, fontSize:10, display:'flex', alignItems:'center', justifyContent:'center', cursor:'pointer'}}>x</div>
                               </div>
                           ))}
                       </div>
                   </div>
                </div>
              </div>
            </div>
          ))}
          <button type="button" onClick={addChapterForm} className="btn-publish" style={{ background: '#f3f4f6', color: '#4b5563', border: '2px dashed #d1d5db', boxShadow: 'none' }}><Plus size={24} /> ADD CHAPTER</button>
        </div>

        {loading && (
            <div style={{ position: 'fixed', bottom: 20, left: '50%', transform: 'translateX(-50%)', width: '90%', maxWidth: 600, background: 'white', padding: 20, borderRadius: 20, boxShadow: '0 20px 50px rgba(0,0,0,0.2)', border: '1px solid #e5e7eb', zIndex: 100 }}>
              <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: 10 }}>
                <div style={{ display: 'flex', alignItems: 'center', gap: 15 }}>
                  <Loader2 className="animate-spin" color="#db2777" />
                  <div>
                    <div style={{ fontWeight: 800, color: '#1f2937' }}>{status}</div>
                  </div>
                </div>
                <div style={{ fontWeight: 900, color: '#db2777', fontSize: '1.2rem' }}>{progress}%</div>
              </div>
              <div style={{ width: '100%', height: 8, background: '#fce7f3', borderRadius: 10, overflow: 'hidden' }}>
                <div style={{ width: `${progress}%`, height: '100%', background: '#db2777', transition: 'width 0.3s ease' }}></div>
              </div>
            </div>
        )}

      </form>
    </div>
  );
}